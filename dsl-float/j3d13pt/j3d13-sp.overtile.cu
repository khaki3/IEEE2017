/*
 * j3d7-sp.sdsl.c: This file is part of the SDSLC project.
 *
 * SDSLC: A compiler for high performance stencil computations
 *
 * Copyright (C) 2011-2013 Ohio State University
 *
 * This program can be redistributed and/or modified under the terms
 * of the license specified in the LICENSE.txt file at the root of the
 * project.
 *
 * Contact: P Sadayappan <saday@cse.ohio-state.edu>
 */

/*
 * @file: j3d7-sp.sdsl.c
 * @author: Tom Henretty <henretty@cse.ohio-state.edu>
 */
#include <stdlib.h>
#include <stdio.h>
#include <sys/time.h>
#include <math.h>
#include <assert.h>

const float ONESEVENTH = (0.142857143f);

// Problem parameters
#ifndef D
#define D (512)
#endif

#ifndef H
#define H (512)
#endif

#ifndef W
#define W (512)
#endif
                                                                    
#ifndef T
#define T (4)
#endif

  
float aref[2][D][H][W];
float a[D][H][W];


/** Main program */
int main(int argc, char* argv[]) {
  int i, j, k, ii, jj, kk, t, tt;
  double refElapsed, sdslElapsed;
  double refGFLOPS, sdslGFLOPS;
  float (*inref)[H][W], (*outref)[H][W];
  float *asdsl = &a[0][0][0];
  
  // Initialize arrays
  for (i = 0; i < D; i++) {
    for (j = 0; j < H; j++) {
      for (k = 0; k < W; k++) {
        aref[0][i][j][k] = aref[1][i][j][k] = sin(i)*cos(j)*tan(k);
        a[i][j][k] = sin(i)*cos(j)*tan(k);
      }
    }
  }
  
  // Compute reference
  #ifndef NOREF
  for (t = 0; t < T; t++) {
    inref  = aref[t & 1];
    outref = aref[(t + 1) & 1];
    for (i = 2; i < D - 2; i++) {
      for (j = 2; j < H - 2; j++) {
        #pragma ivdep
        #pragma vector always
        for (k = 2; k < W - 2; k++) {
          outref[i][j][k] =
            0.083f * inref[i][j][k+2] + 0.083f * inref[i][j][k+1] +
            0.083f * inref[i][j][k-1] + 0.083f * inref[i][j][k-2] +
            0.083f * inref[i][j+2][k] + 0.083f * inref[i][j+1][k] +
            0.083f * inref[i][j-1][k] + 0.083f * inref[i][j-2][k] +
            0.083f * inref[i+2][j][k] + 0.083f * inref[i+1][j][k] +
            0.083f * inref[i-1][j][k] + 0.083f * inref[i-2][j][k] -
            0.996f * inref[i][j][k];
        }
      }
    }
  }
  #endif
  
  
  // Compute SDSL
  const int dim0 = W;
  const int dim1 = H;
  const int dim2 = D;
  
    int sdsl_ot_wrap_81cb6199463466a1614d3964d30024007ab4ca9c(float *p_asdsl, int sdsl_dim0, int sdsl_dim1, int sdsl_dim2, float sdsl_ONESEVENTH);
  const int sdsl_return_0 = sdsl_ot_wrap_81cb6199463466a1614d3964d30024007ab4ca9c(asdsl, dim0, dim1, dim2, ONESEVENTH);

  
  // Check correctness
  outref = aref[T & 1];float maxDiff = 0.0, sumDiff = 0.0, diff, meanDiff;
  int numDiff = 0;
  for (i = 8; i < D-8; i++) {
    for (j = 8; j < H-8; j++) {
      for (k = 8; k < W-8; k++) {
        diff = fabs(outref[i][j][k] - a[i][j][k]);
        if (diff > 0.0001f) {
          numDiff++;
          sumDiff += diff;
        }
        if (diff > maxDiff) {
          maxDiff = diff;
        }
      }
    }
  }
  meanDiff = sumDiff/((float)(H*W));
  
  printf("Num diff  = %d\n",numDiff);
  printf("Sum diff  = %.8f\n",sumDiff);
  printf("Mean diff = %.8f\n",meanDiff);
  printf("Max diff  = %.8f\n",maxDiff);
  
  return sdsl_return_0;
}
#include <float.h>
//
// Generated by OverTile
//
// Description:
// CUDA device code
//
__global__
static void ot_kernel_sdsl_program_81cb6199463466a1614d3964d30024007ab4ca9c(float *In_asdsl, float *Out_asdsl, int Dim_0, int Dim_1, int Dim_2, float ONESEVENTH) {
  const int BlockIdx_x = blockIdx.x;
  const int BlockIdx_y = blockIdx.y;
  const int BlockIdx_z = blockIdx.z;
  const int GridDim_x = gridDim.x;
  const int GridDim_y = gridDim.y;
  const int GridDim_z = gridDim.z;
  __shared__ float Shared_asdsl[8+2+2][8+2+2][16+2+2];
  const int Halo_Left_0 = 2;
  const int Halo_Right_0 = 2;
  const int Halo_Left_1 = 2;
  const int Halo_Right_1 = 2;
  const int Halo_Left_2 = 2;
  const int Halo_Right_2 = 2;
  int real_per_block_0 = 1*blockDim.x - Halo_Left_0 - Halo_Right_0;
  int real_per_block_1 = 1*blockDim.y - Halo_Left_1 - Halo_Right_1;
  int real_per_block_2 = 1*blockDim.z - Halo_Left_2 - Halo_Right_2;
  int array_size = Dim_0 * Dim_1 * Dim_2;
  const int ts_0 = 1;
  const int ts_1 = 1;
  const int ts_2 = 1;
  float Buffer_asdsl[1][1][1];
  int max_left_offset_0 = 2;
  int max_right_offset_0 = 2;
  int max_left_offset_1 = 2;
  int max_right_offset_1 = 2;
  int max_left_offset_2 = 2;
  int max_right_offset_2 = 2;
int AddrOffset;
  // Kernel init
  int local_0 = threadIdx.x;
  int group_0 = BlockIdx_x;
  int tid_0 = group_0 * real_per_block_0 + local_0 - Halo_Left_0;
  int local_1 = threadIdx.y;
  int group_1 = BlockIdx_y;
  int tid_1 = group_1 * real_per_block_1 + local_1*1 - Halo_Left_1;
  int local_2 = threadIdx.z;
  int group_2 = BlockIdx_z;
  int tid_2 = group_2 * real_per_block_2 + local_2*1 - Halo_Left_2;
  // First time step
 if (BlockIdx_x == 0 || BlockIdx_x == GridDim_x-1 || BlockIdx_y == 0 || BlockIdx_y == GridDim_y-1 || BlockIdx_z == 0 || BlockIdx_z == GridDim_z-1 ) {
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
  for (unsigned elem_2 = 0; elem_2 < ts_2; ++elem_2) {
  int thisid_2 = tid_2 + elem_2;
  int thislocal_2 = threadIdx.z*ts_2 + elem_2;
  if ((thisid_0 >= (0+2) && thisid_0 <= (Dim_0-2-1)) && (thisid_1 >= (0+2) && thisid_1 <= (Dim_1-2-1)) && (thisid_2 >= (0+2) && thisid_2 <= (Dim_2-2-1))) {
{
AddrOffset = (thisid_0+2) + (thisid_1+0)*Dim_0 + (thisid_2+0)*Dim_0*Dim_1;
float asdsl_p2_0_0 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+1) + (thisid_1+0)*Dim_0 + (thisid_2+0)*Dim_0*Dim_1;
float asdsl_p1_0_0 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+-1) + (thisid_1+0)*Dim_0 + (thisid_2+0)*Dim_0*Dim_1;
float asdsl_m1_0_0 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+-2) + (thisid_1+0)*Dim_0 + (thisid_2+0)*Dim_0*Dim_1;
float asdsl_m2_0_0 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+0) + (thisid_1+2)*Dim_0 + (thisid_2+0)*Dim_0*Dim_1;
float asdsl_0_p2_0 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+0) + (thisid_1+1)*Dim_0 + (thisid_2+0)*Dim_0*Dim_1;
float asdsl_0_p1_0 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+0) + (thisid_1+-1)*Dim_0 + (thisid_2+0)*Dim_0*Dim_1;
float asdsl_0_m1_0 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+0) + (thisid_1+-2)*Dim_0 + (thisid_2+0)*Dim_0*Dim_1;
float asdsl_0_m2_0 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+0) + (thisid_1+0)*Dim_0 + (thisid_2+2)*Dim_0*Dim_1;
float asdsl_0_0_p2 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+0) + (thisid_1+0)*Dim_0 + (thisid_2+1)*Dim_0*Dim_1;
float asdsl_0_0_p1 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+0) + (thisid_1+0)*Dim_0 + (thisid_2+-1)*Dim_0*Dim_1;
float asdsl_0_0_m1 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+0) + (thisid_1+0)*Dim_0 + (thisid_2+-2)*Dim_0*Dim_1;
float asdsl_0_0_m2 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+0) + (thisid_1+0)*Dim_0 + (thisid_2+0)*Dim_0*Dim_1;
float asdsl_0_0_0 = *(In_asdsl + AddrOffset);
  float Res = ((((((((((((((0.082999996f)*asdsl_p2_0_0)+((0.082999996f)*asdsl_p1_0_0))+((0.082999996f)*asdsl_m1_0_0))+((0.082999996f)*asdsl_m2_0_0))+((0.082999996f)*asdsl_0_p2_0))+((0.082999996f)*asdsl_0_p1_0))+((0.082999996f)*asdsl_0_m1_0))+((0.082999996f)*asdsl_0_m2_0))+((0.082999996f)*asdsl_0_0_p2))+((0.082999996f)*asdsl_0_0_p1))+((0.082999996f)*asdsl_0_0_m1))+((0.082999996f)*asdsl_0_0_m2))-((0.99599999f)*asdsl_0_0_0));
  Buffer_asdsl[elem_2][elem_1][elem_0] = Res;
  }
} else if ((thisid_0 >= 0 && thisid_0 < Dim_0) && (thisid_1 >= 0 && thisid_1 < Dim_1) && (thisid_2 >= 0 && thisid_2 < Dim_2)) {
AddrOffset = (thisid_0+0) + (thisid_1+0)*Dim_0 + (thisid_2+0)*Dim_0*Dim_1;
float temp = *(In_asdsl + AddrOffset);
  Buffer_asdsl[elem_2][elem_1][elem_0] = temp;
  } else {
  Buffer_asdsl[elem_2][elem_1][elem_0] = 0;
  }
  }
  }
  }
  } else {
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
  for (unsigned elem_2 = 0; elem_2 < ts_2; ++elem_2) {
  int thisid_2 = tid_2 + elem_2;
  int thislocal_2 = threadIdx.z*ts_2 + elem_2;
AddrOffset = (thisid_0+2) + (thisid_1+0)*Dim_0 + (thisid_2+0)*Dim_0*Dim_1;
float asdsl_p2_0_0 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+1) + (thisid_1+0)*Dim_0 + (thisid_2+0)*Dim_0*Dim_1;
float asdsl_p1_0_0 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+-1) + (thisid_1+0)*Dim_0 + (thisid_2+0)*Dim_0*Dim_1;
float asdsl_m1_0_0 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+-2) + (thisid_1+0)*Dim_0 + (thisid_2+0)*Dim_0*Dim_1;
float asdsl_m2_0_0 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+0) + (thisid_1+2)*Dim_0 + (thisid_2+0)*Dim_0*Dim_1;
float asdsl_0_p2_0 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+0) + (thisid_1+1)*Dim_0 + (thisid_2+0)*Dim_0*Dim_1;
float asdsl_0_p1_0 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+0) + (thisid_1+-1)*Dim_0 + (thisid_2+0)*Dim_0*Dim_1;
float asdsl_0_m1_0 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+0) + (thisid_1+-2)*Dim_0 + (thisid_2+0)*Dim_0*Dim_1;
float asdsl_0_m2_0 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+0) + (thisid_1+0)*Dim_0 + (thisid_2+2)*Dim_0*Dim_1;
float asdsl_0_0_p2 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+0) + (thisid_1+0)*Dim_0 + (thisid_2+1)*Dim_0*Dim_1;
float asdsl_0_0_p1 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+0) + (thisid_1+0)*Dim_0 + (thisid_2+-1)*Dim_0*Dim_1;
float asdsl_0_0_m1 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+0) + (thisid_1+0)*Dim_0 + (thisid_2+-2)*Dim_0*Dim_1;
float asdsl_0_0_m2 = *(In_asdsl + AddrOffset);
AddrOffset = (thisid_0+0) + (thisid_1+0)*Dim_0 + (thisid_2+0)*Dim_0*Dim_1;
float asdsl_0_0_0 = *(In_asdsl + AddrOffset);
  float Res = ((((((((((((((0.082999996f)*asdsl_p2_0_0)+((0.082999996f)*asdsl_p1_0_0))+((0.082999996f)*asdsl_m1_0_0))+((0.082999996f)*asdsl_m2_0_0))+((0.082999996f)*asdsl_0_p2_0))+((0.082999996f)*asdsl_0_p1_0))+((0.082999996f)*asdsl_0_m1_0))+((0.082999996f)*asdsl_0_m2_0))+((0.082999996f)*asdsl_0_0_p2))+((0.082999996f)*asdsl_0_0_p1))+((0.082999996f)*asdsl_0_0_m1))+((0.082999996f)*asdsl_0_0_m2))-((0.99599999f)*asdsl_0_0_0));
  Buffer_asdsl[elem_2][elem_1][elem_0] = Res;
  }
  }
  }
  }
  __syncthreads();
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
  for (unsigned elem_2 = 0; elem_2 < ts_2; ++elem_2) {
  int thisid_2 = tid_2 + elem_2;
  int thislocal_2 = threadIdx.z*ts_2 + elem_2;
Shared_asdsl[thislocal_2+2][thislocal_1+2][thislocal_0+2] = Buffer_asdsl[elem_2][elem_1][elem_0];
  }
  }
  }
  __syncthreads();
  // Remaining time steps
 if (BlockIdx_x == 0 || BlockIdx_x == GridDim_x-1 || BlockIdx_y == 0 || BlockIdx_y == GridDim_y-1 || BlockIdx_z == 0 || BlockIdx_z == GridDim_z-1 ) {
  for (int t = 1; t < 2; ++t) {
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
  for (unsigned elem_2 = 0; elem_2 < ts_2; ++elem_2) {
  int thisid_2 = tid_2 + elem_2;
  int thislocal_2 = threadIdx.z*ts_2 + elem_2;
{
  if ((thisid_0 >= (0+2) && thisid_0 <= (Dim_0-2-1)) && (thisid_1 >= (0+2) && thisid_1 <= (Dim_1-2-1)) && (thisid_2 >= (0+2) && thisid_2 <= (Dim_2-2-1))) {
{
float asdsl_p2_0_0 = Shared_asdsl[thislocal_2+2+0][thislocal_1+2+0][thislocal_0+2+2];
float asdsl_p1_0_0 = Shared_asdsl[thislocal_2+2+0][thislocal_1+2+0][thislocal_0+2+1];
float asdsl_m1_0_0 = Shared_asdsl[thislocal_2+2+0][thislocal_1+2+0][thislocal_0+2+-1];
float asdsl_m2_0_0 = Shared_asdsl[thislocal_2+2+0][thislocal_1+2+0][thislocal_0+2+-2];
float asdsl_0_p2_0 = Shared_asdsl[thislocal_2+2+0][thislocal_1+2+2][thislocal_0+2+0];
float asdsl_0_p1_0 = Shared_asdsl[thislocal_2+2+0][thislocal_1+2+1][thislocal_0+2+0];
float asdsl_0_m1_0 = Shared_asdsl[thislocal_2+2+0][thislocal_1+2+-1][thislocal_0+2+0];
float asdsl_0_m2_0 = Shared_asdsl[thislocal_2+2+0][thislocal_1+2+-2][thislocal_0+2+0];
float asdsl_0_0_p2 = Shared_asdsl[thislocal_2+2+2][thislocal_1+2+0][thislocal_0+2+0];
float asdsl_0_0_p1 = Shared_asdsl[thislocal_2+2+1][thislocal_1+2+0][thislocal_0+2+0];
float asdsl_0_0_m1 = Shared_asdsl[thislocal_2+2+-1][thislocal_1+2+0][thislocal_0+2+0];
float asdsl_0_0_m2 = Shared_asdsl[thislocal_2+2+-2][thislocal_1+2+0][thislocal_0+2+0];
float asdsl_0_0_0 = Shared_asdsl[thislocal_2+2+0][thislocal_1+2+0][thislocal_0+2+0];
  float Res = ((((((((((((((0.082999996f)*asdsl_p2_0_0)+((0.082999996f)*asdsl_p1_0_0))+((0.082999996f)*asdsl_m1_0_0))+((0.082999996f)*asdsl_m2_0_0))+((0.082999996f)*asdsl_0_p2_0))+((0.082999996f)*asdsl_0_p1_0))+((0.082999996f)*asdsl_0_m1_0))+((0.082999996f)*asdsl_0_m2_0))+((0.082999996f)*asdsl_0_0_p2))+((0.082999996f)*asdsl_0_0_p1))+((0.082999996f)*asdsl_0_0_m1))+((0.082999996f)*asdsl_0_0_m2))-((0.99599999f)*asdsl_0_0_0));
  Buffer_asdsl[elem_2][elem_1][elem_0] = Res;
  }
}
  }
  }
  }
}
 __syncthreads();
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
  for (unsigned elem_2 = 0; elem_2 < ts_2; ++elem_2) {
  int thisid_2 = tid_2 + elem_2;
  int thislocal_2 = threadIdx.z*ts_2 + elem_2;
    if ((thisid_0 >= (0+2) && thisid_0 <= (Dim_0-2-1)) && (thisid_1 >= (0+2) && thisid_1 <= (Dim_1-2-1)) && (thisid_2 >= (0+2) && thisid_2 <= (Dim_2-2-1))) {
Shared_asdsl[thislocal_2+2][thislocal_1+2][thislocal_0+2] = Buffer_asdsl[elem_2][elem_1][elem_0];
    }
  }
  }
  }
 __syncthreads();
  }
} else {
  for (int t = 1; t < 2; ++t) {
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
  for (unsigned elem_2 = 0; elem_2 < ts_2; ++elem_2) {
  int thisid_2 = tid_2 + elem_2;
  int thislocal_2 = threadIdx.z*ts_2 + elem_2;
{
{
float asdsl_p2_0_0 = Shared_asdsl[thislocal_2+2+0][thislocal_1+2+0][thislocal_0+2+2];
float asdsl_p1_0_0 = Shared_asdsl[thislocal_2+2+0][thislocal_1+2+0][thislocal_0+2+1];
float asdsl_m1_0_0 = Shared_asdsl[thislocal_2+2+0][thislocal_1+2+0][thislocal_0+2+-1];
float asdsl_m2_0_0 = Shared_asdsl[thislocal_2+2+0][thislocal_1+2+0][thislocal_0+2+-2];
float asdsl_0_p2_0 = Shared_asdsl[thislocal_2+2+0][thislocal_1+2+2][thislocal_0+2+0];
float asdsl_0_p1_0 = Shared_asdsl[thislocal_2+2+0][thislocal_1+2+1][thislocal_0+2+0];
float asdsl_0_m1_0 = Shared_asdsl[thislocal_2+2+0][thislocal_1+2+-1][thislocal_0+2+0];
float asdsl_0_m2_0 = Shared_asdsl[thislocal_2+2+0][thislocal_1+2+-2][thislocal_0+2+0];
float asdsl_0_0_p2 = Shared_asdsl[thislocal_2+2+2][thislocal_1+2+0][thislocal_0+2+0];
float asdsl_0_0_p1 = Shared_asdsl[thislocal_2+2+1][thislocal_1+2+0][thislocal_0+2+0];
float asdsl_0_0_m1 = Shared_asdsl[thislocal_2+2+-1][thislocal_1+2+0][thislocal_0+2+0];
float asdsl_0_0_m2 = Shared_asdsl[thislocal_2+2+-2][thislocal_1+2+0][thislocal_0+2+0];
float asdsl_0_0_0 = Shared_asdsl[thislocal_2+2+0][thislocal_1+2+0][thislocal_0+2+0];
  float Res = ((((((((((((((0.082999996f)*asdsl_p2_0_0)+((0.082999996f)*asdsl_p1_0_0))+((0.082999996f)*asdsl_m1_0_0))+((0.082999996f)*asdsl_m2_0_0))+((0.082999996f)*asdsl_0_p2_0))+((0.082999996f)*asdsl_0_p1_0))+((0.082999996f)*asdsl_0_m1_0))+((0.082999996f)*asdsl_0_m2_0))+((0.082999996f)*asdsl_0_0_p2))+((0.082999996f)*asdsl_0_0_p1))+((0.082999996f)*asdsl_0_0_m1))+((0.082999996f)*asdsl_0_0_m2))-((0.99599999f)*asdsl_0_0_0));
  Buffer_asdsl[elem_2][elem_1][elem_0] = Res;
  }
  }
  }
  }
}
 __syncthreads();
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
  for (unsigned elem_2 = 0; elem_2 < ts_2; ++elem_2) {
  int thisid_2 = tid_2 + elem_2;
  int thislocal_2 = threadIdx.z*ts_2 + elem_2;
    if ((thisid_0 >= (0+2) && thisid_0 <= (Dim_0-2-1)) && (thisid_1 >= (0+2) && thisid_1 <= (Dim_1-2-1)) && (thisid_2 >= (0+2) && thisid_2 <= (Dim_2-2-1))) {
Shared_asdsl[thislocal_2+2][thislocal_1+2][thislocal_0+2] = Buffer_asdsl[elem_2][elem_1][elem_0];
    }
  }
  }
  }
 __syncthreads();
  }
}
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
  for (unsigned elem_2 = 0; elem_2 < ts_2; ++elem_2) {
  int thisid_2 = tid_2 + elem_2;
  int thislocal_2 = threadIdx.z*ts_2 + elem_2;
      if ((thislocal_0 >= Halo_Left_0 && thislocal_0 < blockDim.x*ts_0 - Halo_Right_0 && thisid_0 >= 0 && thisid_0 < Dim_0 - 0) && (thislocal_1 >= Halo_Left_1 && thislocal_1 < blockDim.y*ts_1 - Halo_Right_1 && thisid_1 >= 0 && thisid_1 < Dim_1 - 0) && (thislocal_2 >= Halo_Left_2 && thislocal_2 < blockDim.z*ts_2 - Halo_Right_2 && thisid_2 >= 0 && thisid_2 < Dim_2 - 0)) {
AddrOffset = thisid_0 + thisid_1*Dim_0 + thisid_2*Dim_0*Dim_1;
*(Out_asdsl + AddrOffset) = Buffer_asdsl[elem_2][elem_1][elem_0];
      }
  }
  }
  }
} // End of kernel




//
// Generated by OverTile
//
// Description:
// CUDA host code
//
#include <iostream>
#include <algorithm>
#include <cassert>
int ot_program_sdsl_program_81cb6199463466a1614d3964d30024007ab4ca9c(int timesteps, float *Host_asdsl, int Dim_0, int Dim_1, int Dim_2, float ONESEVENTH) {
  cudaError_t Result;
  int ArraySize = Dim_0*Dim_1*Dim_2;
  float *deviceasdsl_In;
  float *deviceasdsl_Out;
  Result = cudaMalloc(&deviceasdsl_In, sizeof(float)*ArraySize);
  if (Result != cudaSuccess) {return (int)Result;}
  assert(Result == cudaSuccess);
  Result = cudaMalloc(&deviceasdsl_Out, sizeof(float)*ArraySize);
  if (Result != cudaSuccess) {return (int)Result;}
  assert(Result == cudaSuccess);
  float *deviceasdsl_InPtr = deviceasdsl_In;
  float *deviceasdsl_OutPtr = deviceasdsl_Out;
  Result = cudaMemcpy(deviceasdsl_In, Host_asdsl, sizeof(float)*ArraySize, cudaMemcpyHostToDevice);
  if (Result != cudaSuccess) {return (int)Result;}
  assert(Result == cudaSuccess);
  Result = cudaMemcpy(deviceasdsl_Out, deviceasdsl_In, sizeof(float)*ArraySize, cudaMemcpyDeviceToDevice);
  if (Result != cudaSuccess) {return (int)Result;}
  assert(Result == cudaSuccess);
  const int Halo_Left_0 = 2;
  const int Halo_Right_0 = 2;
  const int real_per_block_0 = 16 - Halo_Left_0 - Halo_Right_0;
  const int Halo_Left_1 = 2;
  const int Halo_Right_1 = 2;
  const int real_per_block_1 = 8 - Halo_Left_1 - Halo_Right_1;
  const int Halo_Left_2 = 2;
  const int Halo_Right_2 = 2;
  const int real_per_block_2 = 8 - Halo_Left_2 - Halo_Right_2;
// BS0 = 16
// ES0 = 1
  dim3 block_size(16, 8, 8);
  int num_blocks_0 = Dim_0 / real_per_block_0;
  int extra_0 = Dim_0 % real_per_block_0;
  num_blocks_0 = num_blocks_0 + (extra_0 > 0 ? 1 : 0);
  int num_blocks_1 = Dim_1 / real_per_block_1;
  int extra_1 = Dim_1 % real_per_block_1;
  num_blocks_1 = num_blocks_1 + (extra_1 > 0 ? 1 : 0);
  int num_blocks_2 = Dim_2 / real_per_block_2;
  int extra_2 = Dim_2 % real_per_block_2;
  num_blocks_2 = num_blocks_2 + (extra_2 > 0 ? 1 : 0);
  dim3 grid_size(num_blocks_0, num_blocks_1, num_blocks_2);
  cudaThreadSynchronize();
  for (int t = 0; t < timesteps; t += 2) {
    ot_kernel_sdsl_program_81cb6199463466a1614d3964d30024007ab4ca9c<<<grid_size, block_size>>>(deviceasdsl_InPtr, deviceasdsl_OutPtr, Dim_0, Dim_1, Dim_2, ONESEVENTH);
    cudaError_t Err = cudaGetLastError();
    if(Err != cudaSuccess) {
      std::cerr << "Kernel launch failure (error: " << Err << ")\n";
      std::cerr << cudaGetErrorString(Err) << "\n";
      std::cerr << "num_blocks_0=" << num_blocks_0 << "\n";
      std::cerr << "num_blocks_1=" << num_blocks_1 << "\n";
      std::cerr << "num_blocks_2=" << num_blocks_2 << "\n";
      std::cerr << "block_size_0=16\n";
      std::cerr << "block_size_1=8\n";
      std::cerr << "block_size_2=8\n";
      return (int)Err;
      abort();
    }
    std::swap(deviceasdsl_InPtr, deviceasdsl_OutPtr);
  }
  Result = cudaMemcpy(Host_asdsl, deviceasdsl_InPtr, sizeof(float)*ArraySize, cudaMemcpyDeviceToHost);
  if (Result != cudaSuccess) {return (int)Result;}
  assert(Result == cudaSuccess);
  cudaFree(deviceasdsl_In);
  cudaFree(deviceasdsl_Out);
  return 0;
}
  int sdsl_ot_wrap_81cb6199463466a1614d3964d30024007ab4ca9c(float *p_asdsl, int sdsl_dim0, int sdsl_dim1, int sdsl_dim2, float sdsl_ONESEVENTH) {
  int tt,t,i,j,k,ret = 0;
  float (*asdsl_old)[sdsl_dim1][sdsl_dim0] = (float (*)[sdsl_dim1][sdsl_dim0])malloc(sdsl_dim2*sdsl_dim1*sdsl_dim0*sizeof(float));
  float (*asdsl)[sdsl_dim1][sdsl_dim0] = (float (*)[sdsl_dim1][sdsl_dim0])p_asdsl;
      ret = ot_program_sdsl_program_81cb6199463466a1614d3964d30024007ab4ca9c(4, p_asdsl, sdsl_dim0, sdsl_dim1, sdsl_dim2, sdsl_ONESEVENTH);
return ret;
} // End function definition
